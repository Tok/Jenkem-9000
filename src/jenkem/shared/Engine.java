package jenkem.shared;

import gwt.g2d.client.graphics.canvas.ImageDataAdapter;

import java.util.HashMap;
import java.util.Map;

import jenkem.shared.color.ColorUtil;
import jenkem.shared.color.Cube;
import jenkem.shared.color.IrcColor;

import com.google.gwt.regexp.shared.RegExp;
import com.google.gwt.regexp.shared.SplitResult;

public class Engine {
	private final Cube cube = new Cube();
	private final AsciiScheme asciiScheme = new AsciiScheme();
	
	/**
	 * full-hd mode
	 * @param ImageDataAdapter ida
	 * @return Strings for IRC.
	 */
	public String[] generateHighDef(ImageDataAdapter ida) {
		final Map<String, Integer> colorMap = prepareColorMap();
		final String[] ret = new String[ida.getHeight()];
		
		for (int y = 0; y < ida.getHeight(); y++) {
			ret[y] = "";
			StringBuilder row = new StringBuilder();
			String oldPix; // lets pretend this is FROTRAN :D
			String newPix = null;
			try {
				for (int x = 0; x < ida.getWidth(); x++) {
					final int red = ida.getRed(x, y);
					final int green = ida.getGreen(x, y);
					final int blue = ida.getBlue(x, y);
					oldPix = newPix;
					newPix = cube.getColorChar(colorMap, red, green, blue,
							false); // the cube is used here.
					if (newPix.equals(oldPix)) {
						String charOnly = newPix.substring(newPix.length() - 1,
								newPix.length());
						row.append(charOnly);
					} else {
						if (row.length() > 0) {
							row.append(ColorUtil.CC);
						}
						row.append(ColorUtil.CC);
						row.append(newPix);
					}
				}
				row.append(ColorUtil.CC);
				ret[y] = row.toString();
			} catch (StringIndexOutOfBoundsException aioobe) {
				// happens with images that have an uneven width
				// just ignore this
			}
		}
		return ret;
	}

	/**
	 * super-hybrid mode
	 * @param ImageDataAdapter ida
	 * @return Strings for IRC.
	 */
	public String[] generateSuperHybrid(ImageDataAdapter ida) {
		final int height = Math.round(ida.getHeight() / 2);
		final int width = ida.getWidth();
		final Map<String, Integer> colorMap = prepareColorMap();
		final String[] ret = new String[height];

		//TODO reimplement
		int startX = 0;
//		if (ctx.getKick().equalsIgnoreCase("x") || ctx.getKick().equalsIgnoreCase("xy")) {
// 			startX++; //kick to the left
//		}
		int startY = 0;
//		if (ctx.getKick().equalsIgnoreCase("y") || ctx.getKick().equalsIgnoreCase("xy")) {
//			startY++; //kick down
//		}
		
		
		//     X
		//   +------------>
		// Y | ## ## ##
		//   | ## ## ##
		//   |
		//   | ## ## ##
		//   | ## ## ##
		//   v

		//the loop-counters are initialized according to the 4 possible 'kick' options.
		//the image is looped 2 rows and 2 columns at a time giving 4 pixels
		//to examine inside the loop. everything is generated by examining the relations
		//of the color values between those 4 pixels which is why the kick option even works.
		//(a good anti-aliasing algorithm on the ASCII level would defeat this purpose)

		//loop over the image, 2 pixels at a time
		for (int y = startY; y < height * 2; y = y + 2) {
			try {
				ret[y / 2] = "";
				StringBuilder row = new StringBuilder();
				String oldLeft;
				String newLeft = null;
				String newRight = null;
				for (int x = startX; x < width; x = x + 2) {
					try {
						final double CONTRAST = 0.70;
						Sample sample = new Sample(ida, x, y, CONTRAST);
						
						oldLeft = newLeft;
						newLeft = cube.getColorChar(
							colorMap, sample.getRedLeft(), sample.getGreenLeft(), sample.getBlueLeft()
						);
						newRight = cube.getColorChar(
							colorMap, sample.getRedRight(), sample.getGreenRight(), sample.getBlueRight()
						);

						jenkem.shared.color.Color leftCol = cube.getTwoNearestColors(colorMap, sample.getRedLeft(), sample.getGreenLeft(), sample.getBlueLeft());
						jenkem.shared.color.Color rightCol = cube.getTwoNearestColors(colorMap, sample.getRedRight(), sample.getGreenRight(), sample.getBlueRight());
						jenkem.shared.color.Color leftTopCol = cube.getTwoNearestColors(colorMap, sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft());
						jenkem.shared.color.Color leftBottomCol = cube.getTwoNearestColors(colorMap, sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft());
						jenkem.shared.color.Color rightTopCol = cube.getTwoNearestColors(colorMap, sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight());
						jenkem.shared.color.Color rightBottomCol = cube.getTwoNearestColors(colorMap, sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight());
						//XXX FFFFFFFFUUUUUUUUUUUUUUUUUUUUUUUUUUUU--

						double offset = +32.0D;
						if (cube.isFirstCloserTo(leftBottomCol.getRgb(), leftTopCol.getRgb(), leftCol.getFgRgb(), offset)) {
							if (rightCol.getBg().equals(leftCol.getFg())) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectRightDown(); //d
							} else {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectDown(); // _
							}
						} else if (cube.isFirstCloserTo(leftTopCol.getRgb(), leftBottomCol.getRgb(), leftCol.getFgRgb(), offset)) {
							if (rightCol.getBg().equals(leftCol.getFg())) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectRightUp(); //q
							} else {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectUp(); // "
							}
						}

						if (cube.isFirstCloserTo(rightBottomCol.getRgb(), rightTopCol.getRgb(), rightCol.getFgRgb(), offset)) {
							if (leftCol.getBg().equals(rightCol.getFg())) {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectLeftDown(); //b
							} else {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectDown(); // _
							}
						} else if (cube.isFirstCloserTo(rightTopCol.getRgb(), rightBottomCol.getRgb(), rightCol.getFgRgb(), offset)) {
							if (leftCol.getBg().equals(rightCol.getFg())) { //compare distance instead of equality?
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectLeftUp(); //P
							} else {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectUp(); // "
							}
						}

						if (newLeft.equals(oldLeft)) {
							String charOnly = newLeft.substring(newLeft.length() - 1, newLeft.length());
							row.append(charOnly);
						} else {
							if (row.length() > 0) {
								row.append(ColorUtil.CC);
							}
							row.append(ColorUtil.CC);
							row.append(newLeft);
						}

						if (newRight.equals(newLeft)) {
							String charOnly = newRight.substring(newRight.length() - 1, newRight.length());
							row.append(charOnly);
						} else {
							row.append(ColorUtil.CC);
							row.append(newRight);
						}

					} catch (ArrayIndexOutOfBoundsException aioobe) {
						//depending on the kick settings and the width settings,
						//this happens if the last column of pixels in the resized image is not even.
						//just ignore it and do nothing.
					}
				}
				row.append(ColorUtil.CC);
				ret[y / 2] = postProcessColoredRow(row.toString());
			} catch (StringIndexOutOfBoundsException aioobe) {
				//depending on the kick settings and on the height of the resized image,
				//this happens if the last row is not even.
				//just ignore it and do nothing.
			}
		}
		return ret;
	}
	
	/**
	 * pwntari mode
	 * @param ImageDataAdapter ida
	 * @return Strings for IRC.
	 */
	public String[] generateHybrid(ImageDataAdapter ida) {
		final int height = Math.round(ida.getHeight() / 2);
		final int width = ida.getWidth();
		final Map<String, Integer> colorMap = prepareColorMap();
		final String[] ret = new String[height];

		//FIXME remove redundancies @see generateSuperHybrid
		int startX = 0; //TODO not here
		int startY = 0;
		
		//TODO reimplement
//		if (ctx.getKick().equalsIgnoreCase("x") || ctx.getKick().equalsIgnoreCase("xy")) {
//			startX++;
//		}
//		if (ctx.getKick().equalsIgnoreCase("y") || ctx.getKick().equalsIgnoreCase("xy")) {
//			startY++;
//		}

		for (int y = startY; y < height * 2; y = y + 2) {
			try {
				ret[y / 2] = "";
				StringBuilder row = new StringBuilder();
				String oldLeft;
				String newLeft = null;
				String newRight = null;
				for (int x = startX; x < width; x = x + 2) {
					try {
						final double CONTRAST = 0.70;
						
						//FIXME really y/2 ?
						Sample sample = new Sample(ida, x, y, CONTRAST);
						
						oldLeft = newLeft;
						//TODO reimplement foreground enforcement
						final boolean isEnforceBlackFg = false;
						newLeft = cube.getColorChar(
							colorMap, sample.getRedLeft(), sample.getGreenLeft(), sample.getBlueLeft(), isEnforceBlackFg
						);
						newRight = cube.getColorChar(
							colorMap, sample.getRedRight(), sample.getGreenRight(), sample.getBlueRight(), isEnforceBlackFg
						);

						if (asciiScheme.isCharacterBright(newLeft) && asciiScheme.isCharacterDark(newRight)) {
							newLeft = asciiScheme.replace(newLeft, asciiScheme.selectVline());
						}
						if (asciiScheme.isCharacterDark(newLeft) && asciiScheme.isCharacterBright(newRight)) {
							newRight = asciiScheme.replace(newRight, asciiScheme.selectVline());
						}

						//TODO this is all ugly
						//XXX tune this
						int downOffset = 21;
						int upOffset = 13;

						int genUpDownOffset = 3;
						int downUpOffset = 1;
						int upDownOffset = 2;

						if (isUp(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), upOffset)) {
							if (asciiScheme.isCharacterDark(newRight)) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectRightUp(); // y7
							} else {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectUp(); // "
							}
						} else if (isDown(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), downOffset)) {
							if (asciiScheme.isCharacterDark(newRight)) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectRightDown(); // j
							} else {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectDown(); // _
							}
						}
						if (isUp(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), upOffset)) {
							if (asciiScheme.isCharacterDark(newLeft)) {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectLeftUp(); // F
							} else {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectUp(); // "
							}
						} else if (isDown(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), downOffset)) {
							if (asciiScheme.isCharacterDark(newLeft)) {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectLeftDown(); // L
							} else {
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectDown(); // _
							}
						}

						if (isUp(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), genUpDownOffset)
								&& isDown(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), genUpDownOffset)
								&& isDown(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), genUpDownOffset)
								&& isUp(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), genUpDownOffset)) {
							newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectLeft(); // <[(
							newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectRight(); // >])
						} else {
							if (isUp(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), upDownOffset)
									&& isDown(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), upDownOffset)) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectUpDown().substring(0, 1); // \\"_',
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectUpDown().substring(1, 2); // \\"_',
							}
							if (isDown(sample.getRedTopLeft(), sample.getGreenTopLeft(), sample.getBlueTopLeft(), sample.getRedBottomLeft(), sample.getGreenBottomLeft(), sample.getBlueBottomLeft(), downUpOffset)
									&& isUp(sample.getRedTopRight(), sample.getGreenTopRight(), sample.getBlueTopRight(), sample.getRedBottomRight(), sample.getGreenBottomRight(), sample.getBlueBottomRight(), downUpOffset)) {
								newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectDownUp().substring(0, 1); // //_".'
								newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectDownUp().substring(1, 2); // //_".'
							}
						}

						if (newLeft.equals(oldLeft)) {
							String charOnly = newLeft.substring(newLeft.length() - 1, newLeft.length());
							row.append(charOnly);
						} else {
							if (row.length() > 0) {
								row.append(ColorUtil.CC);
							}
							row.append(ColorUtil.CC);
							row.append(newLeft);
						}

						if (newRight.equals(newLeft)) {
							String charOnly = newRight.substring(newRight.length() - 1, newRight.length());
							row.append(charOnly);
						} else {
							row.append(ColorUtil.CC);
							row.append(newRight);
						}

					} catch (ArrayIndexOutOfBoundsException aioobe) {
						//depending on the kick settings and the width settings,
						//this happens if the last column of pixels in the resized image is not even.
						//just ignore it and do nothing.
					}
				}
				row.append(ColorUtil.CC);
				ret[y / 2] = postProcessColoredRow(row.toString());
			} catch (StringIndexOutOfBoundsException sioobe) {
				//depending on the kick settings and the width settings,
				//this happens if the last column of pixels in the resized image is not even.
				//just ignore it and do nothing.
			}
		}
		return removeEmptyLines(ret);
	}
	
	/**
	 * Removes empty lines from hybrid output.
	 */
	private String[] removeEmptyLines(String[] input) {
		int emptyCounter = 0;
		for (String line : input) {
			if ("".equals(line)) {
				emptyCounter++;
			}
		}
		String[] result = new String[input.length - emptyCounter];
		int index = 0;
		for (String line : input) {
			if (!line.equals("")) {
				result[index] = line;
				index++;
			}
		}
		return result;
	}
	
	/**
	 * pwntari mode
	 * @param ImageDataAdapter ida
	 * @return Strings for IRC.
	 */
	public String[] generatePwntari(ImageDataAdapter ida) {
		final int height = Math.round(ida.getHeight() / 2);
		final int width = ida.getWidth();
		final Map<String, Integer> colorMap = prepareColorMap();
		final String[] ret = new String[height];
		
		int startX = 0; //TODO not here
		int startY = 0;
		
		//TODO reimplement
//		if (ctx.getKick().equalsIgnoreCase("x") || ctx.getKick().equalsIgnoreCase("xy")) {
//			startX++;
//		}
//		if (ctx.getKick().equalsIgnoreCase("y") || ctx.getKick().equalsIgnoreCase("xy")) {
//			startY++;
//		}
		for (int y = startY; y < height * 2; y = y + 2) {
			try {
				ret[y / 2] = "";
				StringBuilder row = new StringBuilder();
				String oldLeft;
				String newLeft = null;
				String newRight = null;
				for (int x = startX; x < width; x = x + 2) {
					try {
						final double CONTRAST = 0.70;
						Sample sample = new Sample(ida, x, y, CONTRAST);

						oldLeft = newLeft;
						newLeft = cube.getColorChar(
							colorMap, sample.getRedLeft(), sample.getGreenLeft(), sample.getBlueLeft()
						);
						newRight = cube.getColorChar(
							colorMap, sample.getRedRight(), sample.getGreenRight(), sample.getBlueRight()
						);

						newLeft = newLeft.substring(0, newLeft.length() - 1) + asciiScheme.selectDown(); // _
						newRight = newRight.substring(0, newRight.length() - 1) + asciiScheme.selectDown(); // _

						if (newLeft.equals(oldLeft)) {
							String charOnly = newLeft.substring(newLeft.length() - 1, newLeft.length());
							row.append(charOnly);
						} else {
							if (row.length() > 0) {
								row.append(ColorUtil.CC);
							}
							row.append(ColorUtil.CC);
							row.append(newLeft);
						}

						if (newRight.equals(newLeft)) {
							String charOnly = newRight.substring(newRight.length() - 1, newRight.length());
							row.append(charOnly);
						} else {
							row.append(ColorUtil.CC);
							row.append(newRight);
						}
					} catch (ArrayIndexOutOfBoundsException aioobe) {
						//depending on the kick settings and the width settings,
						//this happens if the last column of pixels in the resized image is not even.
						//just ignore it and do nothing.
					}
				}
				row.append(ColorUtil.CC);
				ret[y / 2] = postProcessColoredRow(row.toString());
			} catch (StringIndexOutOfBoundsException aioobe) {
				//depending on the kick settings and the width settings,
				//this happens if the last column of pixels in the resized image is not even.
				//just ignore it and do nothing.
			}
		}
		return ret;
	}
	
	private Map<String, Integer> prepareColorMap() {
		final Map<String, Integer> colorMap = new HashMap<String, Integer>();
		for (IrcColor ic : IrcColor.values()) {
			colorMap.put(ic.name(), ic.getDefaultScheme());
		}
		return colorMap;
	}
	
	private boolean isUp(int topRed, int topGreen, int topBlue, int bottomRed, int bottomGreen, int bottomBlue, int offset){
		return ((topRed + topGreen + topBlue) / 3) <= (127 + offset)
		     && ((bottomRed + bottomGreen + bottomBlue) / 3) > (127 - offset);
	}
	
	private boolean isDown(int topRed, int topGreen, int topBlue, int bottomRed, int bottomGreen, int bottomBlue, int offset){
	     return ((topRed + topGreen + topBlue) / 3) > (127 - offset)
		     && ((bottomRed + bottomGreen + bottomBlue) / 3) <= (127 + offset);
	}
	
	private String postProcessColoredRow(final String row) {
		if (row.indexOf(ColorUtil.CC) <= 0) { //no CC, so process
			StringBuilder result = new StringBuilder();
			result.append(row.substring(0, row.length() - 2));
			result.append(postProcessRow(row.substring(row.length() - 2, row.length())));
			return result.toString();
		} else {
			return row; //can't touch this //TODO throw exception
		}
	}
	
	private String postProcessRow(String row) {
		// 1st procession for the upper part of the characters (true case)
		// 2nd one for the lower parts (false case)
		return postProcessVert(postProcessVert(row, true), false);
	}
	
	/**
	 * makes plain ASCII output smooth
	 * @param row
	 * @param up
	 * true if line is " half, false if _ half of ASCII character
	 * @return the post processed line.
	 */
	private String postProcessVert(String row, boolean up) {
		String replaceBy;
		if (up) { // replace """"""" by "-----"
			replaceBy = asciiScheme.getUp();
		} else { // replace _______ by _-----_
			replaceBy = asciiScheme.getDown();
		}
		
		final String matchMe = replaceBy + replaceBy + "*" + replaceBy;
		RegExp regex = RegExp.compile(matchMe);
		StringBuilder buf = new StringBuilder();
		
		while (regex.test(row)) {
			SplitResult originalStr = regex.split(row);
			StringBuilder line = new StringBuilder();
			for (int i = 0; i < originalStr.length() - 2; i++) {
				// -2 because the first and the last letter is replaced
				line.append(asciiScheme.getHline());
			}
			
//			matcher.appendReplacement(buf, replaceBy + line.toString() + replaceBy);
			//buf.append(replaceBy + line.toString() + replaceBy); //FIXME
		}

//		matcher.appendTail(buf);
//		buf.append(buf); //FIXME

		return buf.toString();
	}
}
