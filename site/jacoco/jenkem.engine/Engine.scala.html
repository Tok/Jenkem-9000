<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Engine.scala</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jenkem</a> &gt; <a href="index.html" class="el_package">jenkem.engine</a> &gt; <span class="el_source">Engine.scala</span></div><h1>Engine.scala</h1><pre class="source lang-java linenums">/*
 * #%L
 * Engine.scala - Jenkem - Tok - 2012
 * %%
 * Copyright (C) 2012 - 2013 Lukas Steiger &lt;lsteiger4@gmail.com&gt;
 * %%
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar.
 * See http://www.wtfpl.net/ for more details.
 * #L%
 */
package jenkem.engine

import scala.Array.canBuildFrom
import scala.util.Random
import jenkem.engine.color.Cube
import jenkem.engine.color.Power
import jenkem.engine.color.Sample
import jenkem.util.ColorUtil
import jenkem.engine.color.Scheme
import jenkem.engine.color.Color
import jenkem.util.ImageUtil

<span class="fc" id="L26">object Engine {</span>
<span class="fc" id="L27">  val comma = &quot;,&quot;</span>

<span class="fc" id="L29">  class Params(</span>
<span class="fc" id="L30">      val method: Method,</span>
<span class="fc" id="L31">      val imageRgb: Color.RgbMap,</span>
<span class="fc" id="L32">      val colorMap: Color.IrcMap,</span>
<span class="fc" id="L33">      val characters: String,</span>
<span class="fc" id="L34">      val settings: Setting.Instance,</span>
<span class="fc" id="L35">      val contrast: Int,</span>
<span class="fc" id="L36">      val brightness: Int,</span>
<span class="fc" id="L37">      val power: Power) {</span>
<span class="fc" id="L38">    val hasAnsi = Pal.hasAnsi(characters)</span>
  }

  def generateLine(par: Params, index: Int): String = {
<span class="fc" id="L42">    par.method match {</span>
<span class="pc bpc" id="L43" title="3 of 6 branches missed.">      case Method.Vortacular =&gt; generateVortacularLine(par, index)</span>
<span class="pc bpc" id="L44" title="3 of 6 branches missed.">      case Method.Pwntari =&gt; generatePwntariLine(par, index)</span>
<span class="fc" id="L45">      case _ =&gt; generatePlainLine(par, index)</span>
    }
  }

  private def generatePwntariLine(par: Params, index: Int): String = {
    def consolidateDuplicates(chars: List[String]): List[String] = {
<span class="fc" id="L51">      def consolidateDuplicates0(chars: List[String], accu: List[String], i: Int): List[String] = {</span>
<span class="fc bfc" id="L52" title="All 4 branches covered.">        if (i == chars.length) { accu }</span>
        else {
<span class="fc" id="L54">          val thisOne = chars(i)</span>
<span class="fc bfc" id="L55" title="All 4 branches covered.">          if (i == 0) { consolidateDuplicates0(chars, accu ::: List(thisOne), i + 1) }</span>
          else {
<span class="fc" id="L57">            val eq = thisOne.equals(chars(i - 1))</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">            val newChar = if (eq) { List(par.characters.head.toString) } else { List(thisOne) }</span>
<span class="fc" id="L59">            consolidateDuplicates0(chars, accu ::: newChar, i + 1)</span>
          }
        }
      }
<span class="fc" id="L63">      consolidateDuplicates0(chars, Nil, 0)</span>
    }
<span class="fc" id="L65">    val indices = (0 until inferWidth(par.imageRgb))</span>
<span class="fc" id="L66">    val t = indices.map(i =&gt; ImageUtil.getPixels(par.imageRgb, i, index))</span>
<span class="fc" id="L67">    val b = indices.map(i =&gt; ImageUtil.getPixels(par.imageRgb, i, index + 1))</span>
<span class="fc" id="L68">    val tIrc = t.map(Cube.getNearest(_, par.colorMap))</span>
<span class="fc" id="L69">    val bIrc = b.map(Cube.getNearest(_, par.colorMap))</span>
<span class="fc" id="L70">    val chars = indices.map(i =&gt; ColorUtil.makePwnIrc(bIrc(i), tIrc(i))).toList</span>
<span class="fc" id="L71">    consolidateDuplicates(chars).mkString</span>
  }

<span class="fc" id="L74">  private def generateVortacularLine(par: Params, index: Int): String = {</span>
    def makeColorSample(x: Int): Sample.Colored = {
<span class="fc" id="L76">      Sample.makeColorSample(par.imageRgb, x, index, par.contrast, par.brightness)</span>
    }
<span class="fc bfc" id="L78" title="All 2 branches covered.">    val sam = (0 until inferWidth(par.imageRgb)).filter(_ % 2 == 0).map(makeColorSample(_)).toList</span>
<span class="fc" id="L79">    val range = (0 until sam.length)</span>
<span class="pc bpc" id="L80" title="45 of 112 branches missed.">    lazy val diffs = Sample.dirs.map(d =&gt; (d, sam.map(Sample.calcRgbDiff(_, d)).toList)).toMap</span>
<span class="pc" id="L81">    lazy val tl = sam.map(_._1)</span>
<span class="pc" id="L82">    lazy val tr = sam.map(_._2)</span>
<span class="pc" id="L83">    lazy val bl = sam.map(_._3)</span>
<span class="pc" id="L84">    lazy val br = sam.map(_._4)</span>
<span class="pc" id="L85">    lazy val tIrc = range.map(i =&gt; Sample.calcMean(tl(i), tr(i))).map(Cube.getNearest(_, par.colorMap)).toList</span>
<span class="pc" id="L86">    lazy val bIrc = range.map(i =&gt; Sample.calcMean(bl(i), br(i))).map(Cube.getNearest(_, par.colorMap)).toList</span>
<span class="pc" id="L87">    lazy val lIrc = range.map(i =&gt; Sample.calcMean(tl(i), bl(i))).map(Cube.getNearest(_, par.colorMap)).toList</span>
<span class="pc" id="L88">    lazy val rIrc = range.map(i =&gt; Sample.calcMean(tr(i), br(i))).map(Cube.getNearest(_, par.colorMap)).toList</span>
<span class="fc" id="L89">    val chars = sam.map(Sample.getAllRgb(_)).map(Cube.getColorChar(par.colorMap, par.characters, par.power, _))</span>
    def getSwitched(i: Int): String = {
      def direct(old: String, setting: Setting): String = {
<span class="pc bpc" id="L92" title="2 of 4 branches missed.">        if (!par.settings.has(setting)) { old }</span>
        else {
<span class="fc" id="L94">          val offset = ((par.settings.get(setting) + 100) * -1) / 4</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">          if (setting.equals(Setting.LEFTRIGHT)) {</span>
<span class="fc bfc" id="L96" title="All 4 branches covered.">            if (lIrc(i) == rIrc(i)) { old }</span>
            else {
<span class="fc" id="L98">              val leftDiff: Short = diffs.get(Sample.LEFT).get(i)</span>
<span class="fc" id="L99">              val rightDiff: Short = diffs.get(Sample.RIGHT).get(i)</span>
<span class="fc bfc" id="L100" title="All 4 branches covered.">              if (leftDiff + offset &lt; rightDiff) {</span>
<span class="fc" id="L101">                lIrc(i) + comma + rIrc(i) + Pal.get(Pal.LEFT, par.hasAnsi, par.characters)</span>
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">              } else if (rightDiff + offset &lt; leftDiff) {</span>
<span class="fc" id="L103">                rIrc(i) + comma + lIrc(i) + Pal.get(Pal.RIGHT, par.hasAnsi, par.characters)</span>
<span class="nc" id="L104">              } else { old }</span>
            }
          } else { //setting.equals(Setting.UPDOWN)
<span class="fc bfc" id="L107" title="All 4 branches covered.">            if (tIrc(i) == bIrc(i)) { old }</span>
            else {
<span class="fc" id="L109">              val topDiff: Short = diffs.get(Sample.TOP).get(i)</span>
<span class="fc" id="L110">              val botDiff: Short = diffs.get(Sample.BOT).get(i)</span>
<span class="fc bfc" id="L111" title="All 4 branches covered.">              if (topDiff + offset &lt; botDiff) {</span>
<span class="fc" id="L112">                tIrc(i) + comma + bIrc(i) + Pal.get(Pal.UP, par.hasAnsi, par.characters)</span>
<span class="pc bpc" id="L113" title="2 of 4 branches missed.">              } else if (botDiff + offset &lt; topDiff) {</span>
<span class="fc" id="L114">                bIrc(i) + comma + tIrc(i) + Pal.get(Pal.DOWN, par.hasAnsi, par.characters)</span>
<span class="nc" id="L115">              } else { old }</span>
            }
          }
        }
      }
<span class="fc" id="L120">      direct(direct(chars(i), Setting.LEFTRIGHT), Setting.UPDOWN)</span>
    }
<span class="fc" id="L122">    val switched = range.map(ColorUtil.CC + getSwitched(_)).toList</span>
<span class="fc" id="L123">    val charsOnly = switched.map(_.last.toString)</span>
<span class="fc" id="L124">    val pp = postProcess(par, charsOnly.mkString, true).toCharArray.map(_.toString).toList</span>

<span class="pc" id="L126">    lazy val reps = Pal.pairs.map(p =&gt; (p, Pal.getValChars(p._1, par.hasAnsi))).toMap</span>
    def change(c: String): String = {
<span class="pc" id="L128">      reps.keys.find(r =&gt; reps(r).contains(c)).map(r =&gt; Pal.get(r._2, par.hasAnsi, par.characters)).getOrElse(c)</span>
    }
<span class="fc" id="L130">    val changed = pp.map(change(_))</span>
<span class="fc" id="L131">    val finalLine = range.map(i =&gt; switched(i).init + changed(i)).toList</span>

    //val finalLine = range.map(i =&gt; switched(i).init + pp(i)).toList
<span class="fc" id="L134">    range.map(makeValid(_, finalLine, switched)).mkString</span>
  }

<span class="fc" id="L137">  private def makeValid(i: Int, list: List[String], switched: List[String]): String = {</span>
<span class="fc" id="L138">    val thisOne = list(i)</span>
<span class="fc bfc" id="L139" title="All 6 branches covered.">    if (i != 0 &amp;&amp; thisOne.init.equals(switched(i - 1).init)) { thisOne.last.toString }</span>
<span class="fc" id="L140">    else { thisOne }</span>
  }

  private def generatePlainLine(par: Params, index: Int): String = {
    def makeGreySample(x: Int): Sample.Grey = {
<span class="fc" id="L145">      Sample.makeGreySample(par.imageRgb, x, index, par.contrast, par.brightness)</span>
    }
<span class="fc bfc" id="L147" title="All 2 branches covered.">    val indices = (0 until inferWidth(par.imageRgb)).filter(_ % 2 == 0)</span>
<span class="fc" id="L148">    val sam = indices.map(makeGreySample(_)).toList</span>
    def getChar(i: Int): String = {
      def getProcessed(setting: Setting,
          firstPal: Pal, secondPal: Pal,
          firstDir: Sample.Dir, secondDir: Sample.Dir): Option[String] = {
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">        if (!par.settings.has(setting)) { None }</span>
        else {
<span class="fc" id="L155">          val fp = Pal.get(firstPal, par.hasAnsi, par.characters)</span>
<span class="fc" id="L156">          val sp = Pal.get(secondPal, par.hasAnsi, par.characters)</span>
<span class="fc" id="L157">          val fs = Sample.getDirectedGrey(sam(i), firstDir)</span>
<span class="fc" id="L158">          val ss = Sample.getDirectedGrey(sam(i), secondDir)</span>
<span class="fc" id="L159">          getFor(par.settings.get(setting) / 10, fs, ss, fp, sp)</span>
        }
      }
<span class="pc" id="L162">      getProcessed(Setting.UPDOWN, Pal.UP, Pal.DOWN, Sample.TOP, Sample.BOT) match {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        case Some(ud) =&gt; ud //first possibility</span>
<span class="pc bpc" id="L164" title="4 of 6 branches missed.">        case None =&gt;</span>
<span class="pc" id="L165">          getProcessed(Setting.LEFTRIGHT, Pal.LEFT, Pal.RIGHT, Sample.LEFT, Sample.RIGHT) match {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            case Some(lr) =&gt; lr //second possibility</span>
<span class="pc bpc" id="L167" title="4 of 6 branches missed.">            case None =&gt; Pal.getCharAbs(par.characters, Sample.getMeanGrey(sam(i))) //default</span>
          }
      }
    }
<span class="fc" id="L171">    val line = (0 until sam.length).map(i =&gt; getChar(i)).mkString</span>
<span class="fc" id="L172">    postProcess(par, line, false)</span>
  }

<span class="fc" id="L175">  private def getFor(offset: Int, first: Int, second: Int, firstChar: String, secondChar: String): Option[String] = {</span>
<span class="fc bfc" id="L176" title="All 4 branches covered.">    val fCond = first &lt;= Color.CENTER + offset &amp;&amp; second &gt; Color.CENTER - offset</span>
<span class="fc bfc" id="L177" title="All 4 branches covered.">    val sCond = first &gt; Color.CENTER - offset &amp;&amp; second &lt;= Color.CENTER + offset</span>
<span class="pc bpc" id="L178" title="2 of 6 branches missed.">    if (fCond &amp;&amp; sCond) { Some(Random.shuffle(List(firstChar, secondChar)).head) }</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">    else if (fCond) { Some(firstChar) }</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">    else if (sCond) { Some(secondChar) }</span>
<span class="fc" id="L181">    else { None }</span>
  }

  type CharMapType = Map[Product, String]

<span class="fc" id="L186">  private def postProcess(par: Params, line: String, hasCol: Boolean): String = {</span>
<span class="pc" id="L187">    lazy val chr: CharMapType = Pal.values.map(v =&gt; (v, Pal.get(v, par.hasAnsi, par.characters))).toMap</span>
<span class="fc" id="L188">    val range = (0 until line.length)</span>
<span class="fc" id="L189">    val lineList = line.map(_.toString).toList</span>
<span class="fc" id="L190">    val dbqp = dbqpLine(lineList, range, par, chr, hasCol)</span>
<span class="fc" id="L191">    val diag = diagLine(dbqp, range, par, chr)</span>
<span class="fc" id="L192">    val hor = horLine(diag, range, par, chr)</span>
<span class="fc" id="L193">    val vert = vertLine(hor, range, par, chr).mkString</span>
<span class="fc" id="L194">    vert</span>
  }

  private def dbqpLine(in: List[String], range: Range, par: Params, chr: CharMapType, hasCol: Boolean): List[String] = {
<span class="fc bfc" id="L198" title="All 4 branches covered.">    if (!par.settings.has(Setting.DBQP)) { in.toList } else { changeDbqp(in, range, par, chr, hasCol) }</span>
  }

  private def changeDbqp(in: List[String], range: Range, par: Params, chr: CharMapType, hasCol: Boolean): List[String] = {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">    def getD: String = if (hasCol) { chr.get(Pal.LEFT_DOWN).get } else { chr.get(Pal.RIGHT_DOWN).get }</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">    def getB: String = if (hasCol) { chr.get(Pal.RIGHT_DOWN).get } else { chr.get(Pal.LEFT_DOWN).get }</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    def getQ: String = if (hasCol) { chr.get(Pal.LEFT_UP).get } else { chr.get(Pal.RIGHT_UP).get }</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    def getP: String = if (hasCol) { chr.get(Pal.RIGHT_UP).get } else { chr.get(Pal.LEFT_UP).get }</span>
<span class="fc" id="L206">    val d = range.map(changeDbqp(in.toList, range, par, _, chr.get(Pal.DOWN).get, getD, false))</span>
<span class="fc" id="L207">    val b = range.map(changeDbqp(d.toList, range, par, _, chr.get(Pal.DOWN).get, getB, true))</span>
<span class="fc" id="L208">    val q = range.map(changeDbqp(b.toList, range, par, _, chr.get(Pal.UP).get, getQ, false))</span>
<span class="fc" id="L209">    val p = range.map(changeDbqp(q.toList, range, par, _, chr.get(Pal.UP).get, getP, true))</span>
<span class="fc" id="L210">    p.toList</span>
  }

<span class="fc bfc" id="L213" title="All 4 branches covered.">  private def isFirstOrLast(i: Int, range: Range): Boolean = i == 0 || i == range.last</span>
<span class="fc" id="L214">  private def changeDbqp(list: List[String], range: Range, par: Params, i: Int, thisOne: String, to: String, darkLeft: Boolean): String = {</span>
<span class="pc" id="L215">    lazy val current: String = list(i)</span>
<span class="pc" id="L216">    lazy val last: String = list(i - 1)</span>
<span class="pc" id="L217">    lazy val next: String = list(i + 1)</span>
<span class="pc" id="L218">    lazy val isCurrentEqual: Boolean = current.equals(thisOne)</span>
<span class="fc" id="L219">    def isLastEqual: Boolean = thisOne.equals(last)</span>
<span class="fc" id="L220">    def isNextEqual: Boolean = thisOne.equals(next)</span>
<span class="fc" id="L221">    def isLastDark: Boolean = Pal.isDark(par.characters, last)</span>
<span class="fc" id="L222">    def isNextDark: Boolean = Pal.isDark(par.characters, next)</span>
<span class="fc" id="L223">    def isLastBright: Boolean = Pal.isBright(par.characters, last)</span>
<span class="fc" id="L224">    def isNextBright: Boolean = Pal.isBright(par.characters, next)</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">    def isLastBrightOrEqual: Boolean = isLastBright || isLastEqual</span>
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">    def isNextBrightOrEqual: Boolean = isNextBright || isNextEqual</span>
<span class="pc bpc" id="L227" title="1 of 6 branches missed.">    def leftCondition: Boolean = darkLeft &amp;&amp; isLastDark &amp;&amp; isNextBrightOrEqual</span>
<span class="pc bpc" id="L228" title="1 of 6 branches missed.">    def rightCondition: Boolean = !darkLeft &amp;&amp; isNextDark &amp;&amp; isLastBrightOrEqual</span>
<span class="fc bfc" id="L229" title="All 4 branches covered.">    def notLeftAndNotRight: Boolean = !leftCondition &amp;&amp; !rightCondition</span>
<span class="fc bfc" id="L230" title="All 8 branches covered.">    if (isFirstOrLast(i, range) || !isCurrentEqual || notLeftAndNotRight) { current } else { to }</span>
  }

  private def diagLine(in: List[String], range: Range, par: Params, chr: CharMapType): List[String] = {
<span class="fc bfc" id="L234" title="All 4 branches covered.">    if (!par.settings.has(Setting.DIAGONAL)) { in.toList }</span>
    else {
<span class="fc" id="L236">      def changeDiag(list: List[String], i: Int): String = {</span>
<span class="pc" id="L237">        lazy val current: String = list(i)</span>
        //lazy val currentEqualsDown = current.equals(chr.get(Pal.DOWN).get)
<span class="pc" id="L239">        lazy val currentEqualsUp = current.equals(chr.get(Pal.UP).get)</span>
<span class="pc" id="L240">        lazy val last: String = list(i - 1)</span>
<span class="pc" id="L241">        lazy val lastEqualsDown = last.equals(chr.get(Pal.DOWN).get)</span>
<span class="pc" id="L242">        lazy val lastEqualsUp = last.equals(chr.get(Pal.UP).get)</span>
<span class="pc" id="L243">        lazy val next: String = list(i + 1)</span>
<span class="pc" id="L244">        lazy val nextEqualsDown = next.equals(chr.get(Pal.DOWN).get)</span>
<span class="pc" id="L245">        lazy val nextEqualsUp = next.equals(chr.get(Pal.UP).get)</span>
<span class="pc bpc" id="L246" title="2 of 4 branches missed.">        lazy val currentOrNextIsUp = currentEqualsUp || nextEqualsUp</span>
<span class="pc bfc" id="L247" title="All 4 branches covered.">        lazy val currentOrLastIsUp = currentEqualsUp || lastEqualsUp</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (isFirstOrLast(i, range)) { current }</span>
<span class="pc bpc" id="L249" title="2 of 6 branches missed.">        else if (lastEqualsDown &amp;&amp; currentOrNextIsUp) { chr.get(Pal.DOWN_UP).get }</span>
<span class="pc bpc" id="L250" title="2 of 6 branches missed.">        else if (currentOrLastIsUp &amp;&amp; nextEqualsDown) { chr.get(Pal.UP_DOWN).get }</span>
<span class="fc" id="L251">        else { current }</span>
      }
<span class="fc" id="L253">      range.map(changeDiag(in.toList, _)).toList</span>
    }
  }

  private def horLine(in: List[String], range: Range, par: Params, chr: CharMapType): List[String] = {
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">    if (!par.settings.has(Setting.HORIZONTAL)) { in.toList }</span>
    else {
<span class="nc" id="L260">      def changeHor(list: List[String], i: Int, from: String, to: String): String = {</span>
<span class="nc" id="L261">        lazy val current: String = list(i)</span>
<span class="nc" id="L262">        lazy val last: String = list(i - 1)</span>
<span class="nc" id="L263">        lazy val next: String = list(i + 1)</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (isFirstOrLast(i, range)) { current }</span>
<span class="nc bnc" id="L265" title="All 8 branches missed.">        else if (last.equals(Pal.darkest(par.characters)) &amp;&amp; current.equals(from) &amp;&amp; next.equals(from)) { to }</span>
<span class="nc bnc" id="L266" title="All 8 branches missed.">        else if (last.equals(from) &amp;&amp; current.equals(from) &amp;&amp; next.equals(Pal.darkest(par.characters))) { to }</span>
<span class="nc" id="L267">        else { current }</span>
      }
<span class="nc" id="L269">      val h = range.map(changeHor(in.toList, _, chr.get(Pal.DOWN).get, chr.get(Pal.H_LINE).get))</span>
<span class="nc" id="L270">      range.map(changeHor(h.toList, _, chr.get(Pal.UP).get, chr.get(Pal.H_LINE).get)).toList</span>
    }
  }

  private def vertLine(in: List[String], range: Range, par: Params, chr: CharMapType): List[String] = {
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">    if (!par.settings.has(Setting.VERTICAL)) { in.toList }</span>
    else {
      def changeVert(list: List[String], i: Int, from: String, to: String): String = {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (list(i).equals(from)) { to } else { list(i) }</span>
      }
<span class="nc" id="L280">      val foo = range.map(changeVert(in.toList, _, chr.get(Pal.LEFT).get, chr.get(Pal.V_LINE).get))</span>
<span class="nc" id="L281">      range.map(changeVert(foo.toList, _, chr.get(Pal.RIGHT).get, chr.get(Pal.V_LINE).get)).toList</span>
    }
  }

  private def inferWidth(imageRgb: Color.RgbMap): Short = {
<span class="fc" id="L286">    (imageRgb.keys.toList.map(t =&gt; t._2).max).shortValue</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.20130617-1803</span></div></body></html>